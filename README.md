# state-zen: 基于设计时蓝图的状态机组合框架（Rust）

> **用一套原语统一表达分层、嵌套、并行状态机以及冲突、优先级等复杂状态机概念，并支持任意组合与静态分析**

state-zen 不是另一个状态机库，而是一个**状态机设计范式**：  
- 所有“复合状态机”（分层、嵌套、并行）都被视为 **`StateMachineBlueprint` 的纯函数变换**  
- 设计者操作的是**声明式蓝图**，而非运行时状态图  
- 一切复杂行为 = 蓝图 + 蓝图 + 分析函数

---

## 💡 核心思想

### 1. **状态机 = 设计时蓝图（Blueprint）**
- `StateMachineBlueprint` 是**纯数据结构**，包含：
  - 状态维度（`StateAspect`）
  - 事件（`Event`）
  - 转移（`Transition`）
  - 观察者（`StateObserver`）
- **运行时只是蓝图的忠实执行者**

### 2. **复合状态机 = 蓝图的函数式组合**
| 传统概念       | state-zen 实现方式                     |
|----------------|----------------------------------------|
| 并行状态机     | `blueprint1.merge(&blueprint2)`        |
| 分层、嵌套状态机     | 通过 `StateInRange` 谓词隐式表达       |
| 状态冲突       | `split_blueprint_by_forbidden_region`  |

> **不再需要特殊语法或运行时支持**——所有复合结构都是**设计时对 blueprint 的变换**。

### 3. **一切皆可分析**
因为蓝图是数据，转移是纯函数（`State → State`），所以：
- 可静态分析“哪些转移会进入禁止区域”
- 可自动拆分、合并、优化蓝图
- 可验证状态机的全局性质

---

## 🧩 原语设计

state-zen 仅需 4 个核心原语：

1. **`StateInRange`**  
   - 状态区域谓词：`&State → bool`  
   - 默认对未提及维度通配，天然支持正交

2. **`Transfer`**  
   - 纯状态转移函数：`&State → State`  
   - 无上下文、无副作用，确保可组合性

3. **`Transition`**  
   - `Event + StateInRange（guard） + Transfer + 优先级 + OnTran`  
   - 完整描述一个转移边

4. **`StateObserver`**  
   - `StateInRange + OnEnter + OnExit`  
   - 自动响应状态区域的进出

> **没有“当前状态”、没有“状态节点”、没有“父状态”**——所有复杂性由谓词和组合表达。

---

## 🔧 设计时工作流

1. **定义原子蓝图**  
   创建独立的、单一职责的状态机蓝图（如移动、饱食度）。

2. **组合复合蓝图**  
   使用 `merge` 将多个蓝图无损合并，形成并行状态机。

3. **分析与优化**  
   使用 `split_blueprint_by_forbidden_region` 等工具函数，分析并修正潜在冲突。

4. **运行时执行**  
   将最终蓝图传入运行时引擎，通过 `event_happen` 和 `transform` 驱动状态变更。

---

## 🌟 为什么这更优雅？

- **统一**：分层、嵌套、并行都归约为 `merge` + `StateInRange`
- **可组合**：蓝图可像积木一样拼接
- **可分析**：纯函数 + 数据结构 = 静态验证可能
- **无运行时开销**：第一里程碑用闭包验证语义，未来可生成零成本代码

---

## 🚧 当前状态（第一里程碑）

- ✅ 完整实现设计时原语
- ✅ 蓝图合并（`merge`）
- ✅ 冲突分析（`split_blueprint_by_forbidden_region`）
- ✅ 端到端运行时验证

> **这不是一个运行时优化项目，而是一个设计范式验证项目**。

---

## 📜 许可证

MIT